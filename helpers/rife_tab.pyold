from __future__ import annotations
import os, re, sys, json, math, stat, shutil, zipfile, platform, subprocess, threading, traceback
from pathlib import Path
from typing import Optional, Tuple, List

import urllib.request, urllib.error
from PySide6 import QtCore, QtWidgets, QtGui

APP_NAME = "RIFE Interpolator"
ORG_NAME = "FrameTools"
VERSION = "tab-1.0"

HELPERS_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = HELPERS_DIR.parent
BIN_DIR = PROJECT_ROOT / "bin"
MODELS_DIR = PROJECT_ROOT / "models"
OUTPUT_DEFAULT = PROJECT_ROOT / "output" / "video" / "interpolated"
WORK_DIR = PROJECT_ROOT / "work"
for d in (BIN_DIR, MODELS_DIR, OUTPUT_DEFAULT, WORK_DIR, WORK_DIR/"frames_in", WORK_DIR/"frames_out"):
    d.mkdir(parents=True, exist_ok=True)

SETTINGS_PATH = PROJECT_ROOT / "settings.json"

GITHUB_RIFE_RELEASE_API = "https://api.github.com/repos/nihui/rife-ncnn-vulkan/releases/latest"
GITHUB_FFMPEG_RELEASE_API = "https://api.github.com/repos/BtbN/FFmpeg-Builds/releases/latest"

def is_windows(): return platform.system() == "Windows"

def make_executable(p: Path):
    if not is_windows():
        try: os.chmod(p, os.stat(p).st_mode | stat.S_IEXEC)
        except Exception: pass

def which(cmd: str):
    from shutil import which as _which; return _which(cmd)

def read_json(path: Path, default):
    try: return json.loads(path.read_text(encoding="utf-8"))
    except Exception: return default

def write_json(path: Path, data):
    try: path.write_text(json.dumps(data, indent=2), encoding="utf-8")
    except Exception: pass

def download_with_progress(url: str, out_path: Path, progress_cb=None, chunk_size=1<<20):
    req = urllib.request.Request(url, headers={"User-Agent": f"{APP_NAME}/{VERSION}"})
    with urllib.request.urlopen(req) as resp:
        total = resp.getheader("Content-Length"); total = int(total) if total else None
        sofar = 0
        with open(out_path, "wb") as f:
            while True:
                chunk = resp.read(chunk_size)
                if not chunk: break
                f.write(chunk); sofar += len(chunk)
                if progress_cb and total: progress_cb(int(sofar/total*100))

def extract_zip(zip_path: Path, dest_dir: Path):
    with zipfile.ZipFile(zip_path, "r") as zf: zf.extractall(dest_dir)

# --------------------------- Tools ---------------------------
class ToolManager(QtCore.QObject):
    log = QtCore.Signal(str); progress = QtCore.Signal(int); status = QtCore.Signal(str)

    def _pick_rife_asset(self, assets: List[dict]) -> Optional[dict]:
        def good(a: dict) -> bool:
            n = a.get("name","").lower()
            return n.endswith(".zip") and ("source" not in n) and ("sha256" not in n)
        cand = [a for a in assets if good(a)]
        if not cand: return None
        sysname = platform.system()
        def score(a: dict) -> int:
            n=a.get("name","").lower(); s=0
            if sysname=="Windows" and ("windows" in n or "win" in n): s+=100
            elif sysname=="Darwin" and ("mac" in n or "osx" in n): s+=100
            elif sysname=="Linux" and ("linux" in n or "ubuntu" in n): s+=100
            s += int(a.get("size",0)) // (1<<20); return s
        cand.sort(key=score, reverse=True); return cand[0]

    def ensure_rife(self) -> Tuple[Path, Path, Path]:
        bin_name = "rife-ncnn-vulkan.exe" if is_windows() else "rife-ncnn-vulkan"
        rife_bin = next((p for p in BIN_DIR.glob("**/*") if p.name.lower()==bin_name.lower()), None)
        if rife_bin and MODELS_DIR.exists(): make_executable(rife_bin); return BIN_DIR, rife_bin, MODELS_DIR

        self.status.emit("Downloading RIFE (rife-ncnn-vulkan) ...")
        req = urllib.request.Request(GITHUB_RIFE_RELEASE_API, headers={"User-Agent": f"{APP_NAME}/{VERSION}"})
        with urllib.request.urlopen(req) as resp: rel = json.load(resp)
        asset = self._pick_rife_asset(rel.get("assets",[]))
        if not asset: raise RuntimeError("No suitable RIFE binary found on GitHub releases.")
        url = asset["browser_download_url"]; name = asset["name"]; pkg = BIN_DIR / name
        download_with_progress(url, pkg, self.progress.emit)
        tmp_dir = BIN_DIR / ("_rife_" + name.replace(".zip","")); tmp_dir.mkdir(parents=True, exist_ok=True)
        extract_zip(pkg, tmp_dir)
        try: pkg.unlink()
        except Exception: pass
        found_parent = None
        for p in tmp_dir.rglob("*"):
            if p.is_file() and p.name.lower()==bin_name.lower():
                found_parent = p.parent; break
        if not found_parent: raise RuntimeError("RIFE binary not found after extraction.")
        for item in found_parent.iterdir():
            dst = BIN_DIR / item.name
            try:
                if item.is_dir():
                    if dst.exists(): shutil.rmtree(dst)
                    shutil.move(str(item), str(dst))
                else:
                    shutil.move(str(item), str(dst))
            except Exception: pass
        try: shutil.rmtree(tmp_dir)
        except Exception: pass
        rife_bin = BIN_DIR / bin_name; make_executable(rife_bin)

        # copy ONLY allowed models from bundle into ./models
        ALLOWED = ("rife-v4", "rife-hd", "rife-uhd", "rife-anime")
        def allowed(name: str) -> bool:
            n = name.lower()
            return any(n.startswith(pfx) for pfx in ALLOWED)
        copied = 0
        for p in BIN_DIR.rglob("*"):
            if p.is_dir() and (p.name.lower()=="models" or p.name.lower().startswith("rife-")):
                if p.name.lower()=="models":
                    for sub in p.iterdir():
                        if sub.is_dir() and allowed(sub.name):
                            dst = MODELS_DIR / sub.name
                            if not dst.exists():
                                shutil.copytree(sub, dst, dirs_exist_ok=True); copied += 1
                else:
                    if allowed(p.name):
                        dst = MODELS_DIR / p.name
                        if not dst.exists():
                            shutil.copytree(p, dst, dirs_exist_ok=True); copied += 1
        if copied == 0:
            MODELS_DIR.mkdir(parents=True, exist_ok=True)
            self.log.emit("No allowed models found in release. Drop one of: rife-v4*, rife-HD, rife-UHD, rife-anime into ./models")
        return BIN_DIR, rife_bin, MODELS_DIR

    def ensure_ffmpeg(self) -> Tuple[Path, Path]:
        ffmpeg = which("ffmpeg.exe" if is_windows() else "ffmpeg")
        ffprobe = which("ffprobe.exe" if is_windows() else "ffprobe")
        if ffmpeg and ffprobe: return Path(ffmpeg), Path(ffprobe)

        ffmpeg_bin = next((p for p in BIN_DIR.glob("**/*") if p.name.lower() in ("ffmpeg","ffmpeg.exe")), None)
        ffprobe_bin = next((p for p in BIN_DIR.glob("**/*") if p.name.lower() in ("ffprobe","ffprobe.exe")), None)
        if ffmpeg_bin and ffprobe_bin:
            make_executable(ffmpeg_bin); make_executable(ffprobe_bin); return ffmpeg_bin, ffprobe_bin

        self.status.emit("Attempting to download FFmpeg ...")
        try:
            req = urllib.request.Request(GITHUB_FFMPEG_RELEASE_API, headers={"User-Agent": f"{APP_NAME}/{VERSION}"})
            with urllib.request.urlopen(req) as resp: rel = json.load(resp); assets = rel.get("assets", [])
        except Exception:
            assets = []

        sysname = platform.system(); asset = None
        if assets:
            if sysname == "Windows":
                pref = [a for a in assets if re.search(r"win64-gpl(?!-shared).*\.zip$", a.get("name",""))] or \
                       [a for a in assets if re.search(r"win64-gpl.*\.zip$", a.get("name",""))]
                asset = pref[0] if pref else None
            elif sysname == "Linux":
                pref = [a for a in assets if re.search(r"linux64-gpl.*\.tar\.xz$", a.get("name",""))]
                asset = pref[0] if pref else None

        if not asset:
            if ffmpeg and ffprobe: return Path(ffmpeg), Path(ffprobe)
            raise RuntimeError("FFmpeg missing; please install FFmpeg or add it to PATH.")

        url = asset["browser_download_url"]; name = asset["name"]; pkg = BIN_DIR / name
        download_with_progress(url, pkg, self.progress.emit)
        if name.endswith(".zip"):
            with zipfile.ZipFile(pkg, "r") as zf: zf.extractall(BIN_DIR)
        else:
            import tarfile
            with tarfile.open(pkg, "r:xz") as tf: tf.extractall(BIN_DIR)
        try: pkg.unlink()
        except Exception: pass

        ffmpeg_bin = next((p for p in BIN_DIR.rglob("*") if p.name.lower() in ("ffmpeg","ffmpeg.exe")), None)
        ffprobe_bin = next((p for p in BIN_DIR.rglob("*") if p.name.lower() in ("ffprobe","ffprobe.exe")), None)
        if not ffmpeg_bin or not ffprobe_bin:
            raise RuntimeError("FFmpeg binaries not found after extraction.")
        make_executable(ffmpeg_bin); make_executable(ffprobe_bin); return ffmpeg_bin, ffprobe_bin

# --------------------------- Worker ---------------------------
class InterpWorker(QtCore.QObject):
    log = QtCore.Signal(str); status = QtCore.Signal(str); progress = QtCore.Signal(int); finished = QtCore.Signal(bool, str)

    def __init__(self, tm: ToolManager, settings: dict, parent=None):
        super().__init__(parent); self.tm = tm; self.settings = settings; self.proc=None; self.cancelled=False

    def _run_cmd(self, args, cwd: Optional[Path]=None, throttle_ms: int=50, log_fp=None, minimal=False,
                 monitor_dir: Path|None=None, monitor_total: int|None=None, mon_ext: str|None=None,
                 ff_total: int|None=None, prog_start: int=0, prog_end: int=100, **popen_kwargs):
        self.log.emit("$ " + " ".join(str(a) for a in args))
        self.proc = subprocess.Popen(args, cwd=str(cwd) if cwd else None,
                                     stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                                     text=True, bufsize=1, universal_newlines=True,
                                     **popen_kwargs)
        import time as _t, re as _re
        last = 0.0; buf=[]; last_prog=-1
        for line in self.proc.stdout:
            line = line.rstrip()
            if log_fp:
                try: log_fp.write(line + "\n")
                except Exception: pass
            if not minimal: buf.append(line)
            now = _t.time()
            if (now-last)*1000 >= throttle_ms:
                if buf and not minimal:
                    self.log.emit("\n".join(buf)); buf.clear()
                last = now
                try:
                    prog = None
                    if monitor_dir and monitor_total and mon_ext:
                        cnt = len(list(monitor_dir.glob(f"*.{mon_ext}")))
                        frac = min(1.0, max(0.0, cnt / max(1, monitor_total)))
                        prog = int(prog_start + frac * (prog_end - prog_start))
                    elif ff_total is not None:
                        m = _re.search(r"frame=\s*(\d+)", line)
                        if m:
                            cur = int(m.group(1))
                            frac = min(1.0, max(0.0, cur / max(1, ff_total)))
                            prog = int(prog_start + frac * (prog_end - prog_start))
                    if prog is not None and prog != last_prog:
                        self.progress.emit(prog); last_prog = prog
                except Exception:
                    pass
            QtCore.QCoreApplication.processEvents()
            if self.cancelled:
                try: self.proc.terminate()
                except Exception: pass
                break
        if buf and not minimal: self.log.emit("\n".join(buf))
        ret = self.proc.wait(); self.proc=None
        if ret != 0 and not self.cancelled:
            raise RuntimeError(f"Command failed with exit code {ret}: {' '.join(str(a) for a in args)}")

    def cancel(self):
        self.cancelled=True
        if self.proc and self.proc.poll() is None:
            try: self.proc.terminate()
            except Exception: pass

    def _ffprobe(self, ffprobe: Path, args: list) -> str:
        out = subprocess.check_output([str(ffprobe), *args], text=True, stderr=subprocess.STDOUT); return out
    def _probe_fps(self, ffprobe: Path, video: Path) -> float:
        out = self._ffprobe(ffprobe, ["-v","0","-select_streams","v:0","-print_format","flat=s=_","-show_entries","stream=avg_frame_rate,r_frame_rate", str(video)])
        m = re.search(r'avg_frame_rate\s*=\s*"(\d+)/(\d+)"', out) or re.search(r'r_frame_rate\s*=\s*"(\d+)/(\d+)"', out)
        if m and int(m.group(2))!=0: return int(m.group(1))/int(m.group(2))
        return float(self.settings.get("default_input_fps", 24))
    def _probe_duration(self, ffprobe: Path, video: Path) -> float:
        try:
            out = self._ffprobe(ffprobe, ["-v","0","-show_entries","format=duration","-of","default=noprint_wrappers=1:nokey=1", str(video)])
            return max(0.0, float(out.strip()))
        except Exception:
            return 0.0
    def _has_audio(self, ffprobe: Path, video: Path) -> bool:
        try:
            out = self._ffprobe(ffprobe, ["-v","0","-select_streams","a","-show_entries","stream=index","-of","csv=p=0", str(video)])
            return bool(out.strip())
        except subprocess.CalledProcessError:
            return False

    def run(self, input_video: str, output_video: str, target_fps: int,
            model_choice: str, gpu_choice: str, thread_spec: str, keep_temp: bool, use_cpu_fallback: bool,
            mode: str, factor: int, streaming: bool, chunk_size: int, uhd_safety: bool, minimal_logging: bool,
            rife_preset: str, pace_ms: int, png_level: int, use_jpeg: bool, jpeg_q: int, use_nvenc: bool, x264_preset: str):
        try:
            self.status.emit("Preparing tools ...")
            bin_dir, rife_bin, models_dir = self.tm.ensure_rife()
            ffmpeg_bin, ffprobe_bin = self.tm.ensure_ffmpeg()

            logs_dir = PROJECT_ROOT / "work" / "logs"; logs_dir.mkdir(parents=True, exist_ok=True)
            from time import strftime
            log_file = logs_dir / (Path(input_video).stem + "_" + strftime("%Y%m%d-%H%M%S") + ".log")
            log_fp = open(log_file, "w", encoding="utf-8") if minimal_logging else None
            if minimal_logging: self.log.emit(f"Logging to: {log_file}")

            ff_threads = 0  # let FFmpeg decide
            env = os.environ.copy()
            creationflags = 0

            if rife_preset != "Custom":
                if rife_preset == "Turbo": thread_spec = "2:3:3"
                elif rife_preset == "Balanced": thread_spec = "1:2:2"
                elif rife_preset == "Eco": thread_spec = "1:1:1"

            frames_in = WORK_DIR / "frames_in"; frames_out = WORK_DIR / "frames_out"
            for p in [*frames_in.glob("*.*"), *frames_out.glob("*.png"), *(WORK_DIR.glob("audio.*"))]:
                try: p.unlink()
                except Exception: pass

            iv = Path(input_video); ov = Path(output_video); ov.parent.mkdir(parents=True, exist_ok=True)

            self.status.emit("Probing input FPS ...")
            src_fps = self._probe_fps(ffprobe_bin, iv)
            dur = self._probe_duration(ffprobe_bin, iv)
            self.log.emit(f"Detected input FPS: {src_fps:.3f}")
            if dur>0: self.log.emit(f"Detected duration: {dur:.2f}s (est. frames ~ {int(src_fps*dur)})")

            audio_path=None
            if self._has_audio(ffprobe_bin, iv):
                self.status.emit("Extracting audio ...")
                audio_path = WORK_DIR / "audio.wav"
                cmd = [str(ffmpeg_bin), "-y", "-threads", str(ff_threads), "-i", str(iv), "-vn", "-ac","2","-ar","48000","-c:a","pcm_s16le", str(audio_path)]
                self._run_cmd(cmd, env=env, creationflags=creationflags, throttle_ms=100, log_fp=log_fp, minimal=minimal_logging)
            else:
                self.log.emit("No audio stream detected; continuing without audio.")

            # Decode frames (0–15%)
            self.status.emit("Decoding frames ...")
            ext = "jpg" if use_jpeg else "png"
            out_pat = frames_in / ("frame_%08d." + ext)
            if use_jpeg:
                cmd = [str(ffmpeg_bin), "-y", "-threads", str(ff_threads), "-i", str(iv), "-qscale:v", str(jpeg_q), "-vcodec", "mjpeg", str(out_pat)]
            else:
                cmd = [str(ffmpeg_bin), "-y", "-threads", str(ff_threads), "-i", str(iv), "-compression_level", str(int(png_level)), str(out_pat)]
            est_frames = max(1, int(src_fps*dur)) if dur>0 else None
            self._run_cmd(cmd, env=env, creationflags=creationflags, throttle_ms=100, log_fp=log_fp, minimal=minimal_logging,
                          monitor_dir=frames_in, monitor_total=est_frames, mon_ext=ext, prog_start=0, prog_end=15)

            in_frames = sorted(frames_in.glob("frame_*.jpg" if use_jpeg else "frame_*.png"))
            if len(in_frames) < 2: raise RuntimeError("Not enough frames decoded from input.")
            try: self.progress.emit(15)
            except Exception: pass

            if mode == "factor":
                ratio = float(factor); target_fps_eff = src_fps * ratio
            else:
                ratio = max(1.0, float(target_fps) / max(1e-6, src_fps)); target_fps_eff = float(target_fps)
            target_count = int(math.ceil(len(in_frames) * ratio))
            self.log.emit(f"Target output frames: {target_count} (effective FPS ~ {target_fps_eff:.3f})")

            # Pick model (prefer v4.* or allowed)
            def pick_model_dir(models_dir: Path, preferred: str):
                def allowed_name(name: str) -> bool:
                    n = name.lower()
                    return n.startswith("rife-v4") or n.startswith("rife-hd") or n.startswith("rife-uhd") or n.startswith("rife-anime")
                if preferred and preferred != "Auto":
                    md = models_dir / preferred
                    if md.exists() and md.is_dir() and allowed_name(md.name): return md, md.name.lower().startswith("rife-v4")
                cands=[]
                for d in models_dir.iterdir():
                    if d.is_dir() and allowed_name(d.name):
                        name=d.name.lower(); m=re.match(r"rife-v(\d+)(?:\.(\d+))?", name)
                        if m: major=int(m.group(1)); minor=int(m.group(2) or 0)
                        else: major, minor = (4 if "v4" in name else 0), 0
                        cands.append((major, minor, d))
                if not cands: return None, False
                cands.sort(key=lambda t:(t[0],t[1]), reverse=True)
                for major, minor, d in cands:
                    if major >= 4: return d, True
                major, minor, d = cands[0]; return d, major>=4
            chosen_model_dir, supports_n = pick_model_dir(models_dir, model_choice)
            if not chosen_model_dir: raise RuntimeError("No allowed models in ./models. Add one of: rife-v4*, rife-HD, rife-UHD, rife-anime.")
            self.log.emit(f"Using model: {chosen_model_dir.name}")
            if not supports_n: raise RuntimeError("Selected model does not support custom -n. Please use a v4.* model (e.g., rife-v4.6).")

            def build_args(in_dir: Path, out_dir: Path, n_frames: int) -> List[str]:
                args = [str(rife_bin), "-i", str(in_dir), "-o", str(out_dir), "-m", str(chosen_model_dir), "-n", str(n_frames)]
                if thread_spec.strip(): args += ["-j", thread_spec.strip()]
                if gpu_choice == "CPU (-1)": args += ["-g","-1"]
                elif re.fullmatch(r"-?\d+(,-?\d+)*", gpu_choice.strip() or ""): args += ["-g", gpu_choice.strip()]
                if uhd_safety: args += ["-u"]
                return args

            # Interpolation (15–90%)
            self.status.emit("Running RIFE interpolation ...")
            if not streaming:
                rife_args = build_args(frames_in, frames_out, target_count)
                try:
                    self._run_cmd(rife_args, cwd=BIN_DIR, env=env, creationflags=creationflags, throttle_ms=200, log_fp=log_fp, minimal=minimal_logging,
                                  monitor_dir=frames_out, monitor_total=target_count, mon_ext="png", prog_start=15, prog_end=90)
                except RuntimeError as e:
                    if use_cpu_fallback and "vk" in str(e).lower():
                        self.log.emit("Vulkan failed; retrying CPU ...")
                        cpu_args = [a for a in rife_args if a not in ("-g","-1")] + ["-g","-1"]
                        self._run_cmd(cpu_args, cwd=BIN_DIR, env=env, creationflags=creationflags, throttle_ms=200, log_fp=log_fp, minimal=minimal_logging,
                                      monitor_dir=frames_out, monitor_total=target_count, mon_ext="png", prog_start=15, prog_end=90)
                    else: raise
            else:
                in_list=in_frames; total=len(in_list); out_index=1
                chunk_size=max(30,int(chunk_size))
                self.log.emit(f"Streaming mode ON: chunk_size={chunk_size} (1-frame overlap)")
                tmp_chunks = WORK_DIR / "chunks"
                if tmp_chunks.exists(): shutil.rmtree(tmp_chunks)
                tmp_chunks.mkdir(parents=True, exist_ok=True)
                pos=0
                while pos<total:
                    end=min(total, pos+chunk_size + (1 if pos+chunk_size<total else 0))
                    chunk_files = in_list[pos:end]
                    c_in=tmp_chunks/f"in_{pos:08d}"; c_out=tmp_chunks/f"out_{pos:08d}"
                    c_in.mkdir(parents=True, exist_ok=True); c_out.mkdir(parents=True, exist_ok=True)
                    for idx, pth in enumerate(chunk_files, start=1): shutil.copy2(pth, c_in / f"{idx:08d}.png")
                    c_target=int(math.ceil(len(chunk_files)*ratio))
                    self._run_cmd(build_args(c_in,c_out,c_target), cwd=BIN_DIR, env=env, creationflags=creationflags, throttle_ms=200, log_fp=log_fp, minimal=minimal_logging,
                                  monitor_dir=frames_out, monitor_total=target_count, mon_ext="png", prog_start=15, prog_end=90)
                    out_files=sorted(c_out.glob("*.png"))
                    if pos>0 and out_files: out_files=out_files[1:]
                    for f in out_files:
                        shutil.copy2(f, frames_out / f"{out_index:08d}.png"); out_index+=1
                    pos+=chunk_size
                    if pace_ms>0: QtCore.QThread.msleep(int(pace_ms))
                try: shutil.rmtree(tmp_chunks)
                except Exception: pass

            # Encode (90–100%)
            self.status.emit("Encoding final video ...")
            ff_args = [str(ffmpeg_bin), "-y", "-threads", str(ff_threads),
                       "-framerate", str(int(round(target_fps_eff))),
                       "-i", str(frames_out / "%08d.png")]
            audio_glob = list(WORK_DIR.glob("audio.*"))
            if audio_glob:
                ff_args += ["-i", str(audio_glob[0]), "-c:a","aac","-b:a","192k"]
            if self.settings.get("use_nvenc", False):
                ff_args += ["-c:v","h264_nvenc","-preset","p4","-rc","vbr","-cq", str(self.settings.get("crf", 18))]
            else:
                ff_args += ["-c:v","libx264","-preset", self.settings.get("x264_preset","veryfast"), "-pix_fmt","yuv420p","-crf", str(self.settings.get("crf", 18))]
            ff_args += [str(ov)]
            self._run_cmd(ff_args, env=env, creationflags=creationflags, throttle_ms=100, log_fp=log_fp, minimal=minimal_logging,
                          ff_total=target_count, prog_start=90, prog_end=100)

            if not keep_temp:
                for p in [*frames_in.glob("*.*"), *frames_out.glob("*.png"), *(WORK_DIR.glob("audio.*"))]:
                    try: p.unlink()
                    except Exception: pass

            self.status.emit("Done."); self.progress.emit(100); self.finished.emit(True, str(ov))
            try:
                if log_fp: log_fp.close()
            except Exception: pass
        except Exception as e:
            self.log.emit(traceback.format_exc()); self.status.emit(str(e)); self.finished.emit(False, "")
            try:
                if "log_fp" in locals() and log_fp: log_fp.close()
            except Exception: pass

# --------------------------- Tab Widget ---------------------------
class RifeTab(QtWidgets.QWidget):
    """Embed this in your main window's QTabWidget as RifeTab()."""
    modelsReady = QtCore.Signal(list)
    def __init__(self, parent=None):
        super().__init__(parent)
        self.settings = read_json(SETTINGS_PATH, {
            "default_input_fps": 24, "last_input":"", "last_output":"", "last_fps":60,
            "crf":18, "thread_spec":"1:2:2", "gpu_choice":"Auto", "model_choice":"Auto",
            "keep_temp":False, "cpu_fallback":False, "uhd_safety": False,
            "output_base": str(OUTPUT_DEFAULT), "mode":"fps", "factor": 2,
            "streaming": False, "chunk_size": 300, "minimal_logging": True,
            "rife_preset":"Balanced", "pace_ms":100, "png_level":0, "use_jpeg":False, "jpeg_q":2,
            "use_nvenc": False, "x264_preset":"veryfast"
        })

        self.tm = ToolManager()
        self.tm.log.connect(self._log); self.tm.progress.connect(self._progress); self.tm.status.connect(self._status)
        self.modelsReady.connect(self._set_model_choices)

        outer = QtWidgets.QVBoxLayout(self)
        # Top form
        form = QtWidgets.QFormLayout()

        self.in_edit = QtWidgets.QLineEdit(self.settings.get("last_input",""))
        ib = QtWidgets.QPushButton("Browse..."); ib.clicked.connect(self._browse_in)
        h=QtWidgets.QHBoxLayout(); h.addWidget(self.in_edit,1); h.addWidget(ib)
        w=QtWidgets.QWidget(); w.setLayout(h)
        form.addRow("Input video:", w)

        self.output_base = QtWidgets.QLineEdit(self.settings.get("output_base", str(OUTPUT_DEFAULT)))
        choose_btn = QtWidgets.QPushButton("Choose Folder"); choose_btn.clicked.connect(self._choose_output_base)
        open_btn = QtWidgets.QPushButton("Open Folder"); open_btn.clicked.connect(self._open_output_base)
        hb=QtWidgets.QHBoxLayout(); hb.addWidget(self.output_base,1); hb.addWidget(choose_btn); hb.addWidget(open_btn)
        wb=QtWidgets.QWidget(); wb.setLayout(hb)
        form.addRow("Output folder:", wb)

        self.out_edit = QtWidgets.QLineEdit(self.settings.get("last_output",""))
        ob = QtWidgets.QPushButton("Browse..."); ob.clicked.connect(self._browse_out)
        h2=QtWidgets.QHBoxLayout(); h2.addWidget(self.out_edit,1); h2.addWidget(ob)
        w2=QtWidgets.QWidget(); w2.setLayout(h2)
        form.addRow("Output file:", w2)

        mode_row = QtWidgets.QHBoxLayout()
        self.mode_fps = QtWidgets.QRadioButton("Exact FPS")
        self.mode_factor = QtWidgets.QRadioButton("Factor (×2 / ×4)")
        if self.settings.get("mode","fps") == "factor": self.mode_factor.setChecked(False)  # default removed; will restore via UI
        else: self.mode_fps.setChecked(False)  # default removed; will restore via UI
        self.fps_spin = QtWidgets.QSpinBox();
        try: self.fps_spin.setMinimumWidth(220); self.fps_spin.setFixedHeight(30)
        except Exception: pass
 self.fps_spin.setRange(2,240); self.fps_spin.setValue(int(self.settings.get("last_fps",60)))
        self.fps_spin.setMinimumWidth(140)
        self.factor_combo = QtWidgets.QComboBox();
        try: self.factor_combo.setMinimumWidth(220); self.factor_combo.setFixedHeight(30)
        except Exception: pass
 self.factor_combo.addItems(["2","4"]); self.factor_combo.setCurrentText(str(self.settings.get("factor",2)))
        self.factor_combo.setMinimumWidth(140)
        mode_row.addWidget(self.mode_fps); mode_row.addWidget(self.fps_spin); mode_row.addSpacing(18)
        mode_row.addWidget(self.mode_factor); mode_row.addWidget(self.factor_combo)
        mode_w = QtWidgets.QWidget(); mode_w.setLayout(mode_row)
        form.addRow("Interpolation:", mode_w)

        outer.addLayout(form)

        # Start/Cancel
        btn_row = QtWidgets.QHBoxLayout()
        self.go_btn = QtWidgets.QPushButton("Start"); self.go_btn.clicked.connect(self._start)
        self.cancel_btn = QtWidgets.QPushButton("Cancel"); self.cancel_btn.setEnabled(False); self.cancel_btn.clicked.connect(self._cancel)
        btn_row.addStretch(1); btn_row.addWidget(self.go_btn); btn_row.addWidget(self.cancel_btn)
        outer.addLayout(btn_row)

        # Progress (open)
        prog_sec = CollapsibleSection("Progress", start_collapsed=False)
        prog_l = QtWidgets.QVBoxLayout()
        self.status_lbl = QtWidgets.QLabel("Ready.")
        self.prog = QtWidgets.QProgressBar(); self.prog.setRange(0,100); self.prog.setValue(0)
        self.log = QtWidgets.QPlainTextEdit(); self.log.setReadOnly(True); self.log.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap); self.log.setMinimumHeight(160)
        prog_l.addWidget(self.status_lbl); prog_l.addWidget(self.prog); prog_l.addWidget(self.log,1)
        prog_sec.setContentLayout(prog_l)
        outer.addWidget(prog_sec)

        # Processing options
        proc_sec = CollapsibleSection("Processing options", start_collapsed=True)
        proc_l = QtWidgets.QGridLayout()
        self.model_combo = QtWidgets.QComboBox(); self.model_combo.addItem("Auto")
        self.model_combo.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        self.model_combo.setMinimumContentsLength(16)
        self.model_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)

        self.gpu_combo = QtWidgets.QComboBox(); self.gpu_combo.addItems(["Auto","CPU (-1)","0","1","0,1"])
        self.gpu_combo.setCurrentText(self.settings.get("gpu_choice","Auto"))

        self.thread_edit = QtWidgets.QLineEdit(self.settings.get("thread_spec","1:2:2"))
        self.thread_edit.setPlaceholderText("load:proc:save (e.g., 1:2:2)")

        self.streaming_check = QtWidgets.QCheckBox("Streaming (low memory)")
        self.streaming_check.setChecked(bool(self.settings.get("streaming", False)))
        self.chunk_spin = QtWidgets.QSpinBox(); self.chunk_spin.setRange(30,20000); self.chunk_spin.setValue(int(self.settings.get("chunk_size", 300)))

        r=0
        proc_l.addWidget(QtWidgets.QLabel("Model:"), r, 0); proc_l.addWidget(self.model_combo, r, 1)
        proc_l.addWidget(QtWidgets.QLabel("GPU:"), r, 2); proc_l.addWidget(self.gpu_combo, r, 3); r+=1
        proc_l.addWidget(QtWidgets.QLabel("Threads:"), r, 0); proc_l.addWidget(self.thread_edit, r, 1)
        proc_l.addWidget(QtWidgets.QLabel("Chunk size:"), r, 2); proc_l.addWidget(self.chunk_spin, r, 3); r+=1
        proc_l.addWidget(self.streaming_check, r, 0); self.autoplay_check = QtWidgets.QCheckBox("Auto-play when finished"); self.autoplay_check.setChecked(bool(self.settings.get("autoplay_when_finished", False))); proc_l.addWidget(self.autoplay_check, r, 1); r+=1

        proc_l.addWidget(QtWidgets.QLabel("RIFE preset:"), r, 0)
        self.rife_preset = QtWidgets.QComboBox(); self.rife_preset.addItems(["Turbo","Balanced","Eco","Custom"])
        self.rife_preset.setCurrentText(self.settings.get("rife_preset","Balanced"))
        self.rife_preset.currentTextChanged.connect(self._on_preset_changed)
        proc_l.addWidget(self.rife_preset, r, 1)
        proc_l.addWidget(QtWidgets.QLabel("Pace between chunks (ms):"), r, 2)
        self.pace_spin = QtWidgets.QSpinBox(); self.pace_spin.setRange(0,2000); self.pace_spin.setSingleStep(50); self.pace_spin.setValue(int(self.settings.get("pace_ms",100)))
        proc_l.addWidget(self.pace_spin, r, 3); r+=1

        proc_sec.setContentLayout(proc_l)
        outer.addWidget(proc_sec)

        # Advanced settings
        adv_sec = CollapsibleSection("Advanced settings", start_collapsed=False)

        # Hard-force Advanced section open by default
        try:
            adv_sec.toggle.setChecked(True)
            adv_sec.toggle.setArrowType(QtCore.Qt.DownArrow)
            adv_sec.content.setVisible(True)
            QtCore.QTimer.singleShot(0, lambda: adv_sec.toggle.setChecked(True))
        except Exception:
            pass
        # Force open by default regardless of saved state

        getattr(adv_sec, 'toggle', None) and adv_sec.toggle.setChecked(True)
        adv_l = QtWidgets.QGridLayout()
        self.crf_spin = QtWidgets.QSpinBox(); self.crf_spin.setRange(0,51); self.crf_spin.setValue(int(self.settings.get("crf",18)))
        self.uhd_check = QtWidgets.QCheckBox("UHD safety (-u)"); self.uhd_check.setChecked(bool(self.settings.get("uhd_safety", False)))
        self.keep_temp = QtWidgets.QCheckBox("Keep temp frames"); self.keep_temp.setChecked(bool(self.settings.get("keep_temp", False)))
        self.cpu_fallback = QtWidgets.QCheckBox("Auto CPU fallback"); self.cpu_fallback.setChecked(bool(self.settings.get("cpu_fallback", False)))
        adv_l.addWidget(QtWidgets.QLabel("CRF:"),0,0); adv_l.addWidget(self.crf_spin,0,1); adv_l.addWidget(self.uhd_check,0,2)
        adv_l.addWidget(self.keep_temp,1,0,1,2); adv_l.addWidget(self.cpu_fallback,1,2)
        adv_l.addWidget(QtWidgets.QLabel("PNG level:"),2,0)
        self.png_level = QtWidgets.QSpinBox(); self.png_level.setRange(0,9); self.png_level.setValue(int(self.settings.get("png_level",0)))
        adv_l.addWidget(self.png_level,2,1)
        self.use_jpeg = QtWidgets.QCheckBox("Use JPEG temp frames"); self.use_jpeg.setChecked(bool(self.settings.get("use_jpeg", False)))
        adv_l.addWidget(self.use_jpeg,2,2)
        adv_l.addWidget(QtWidgets.QLabel("JPEG quality:"),3,0)
        self.jpeg_q = QtWidgets.QSpinBox(); self.jpeg_q.setRange(2,31); self.jpeg_q.setValue(int(self.settings.get("jpeg_q",2)))
        adv_l.addWidget(self.jpeg_q,3,1)
        self.use_nvenc = QtWidgets.QCheckBox("Use NVENC for final encode"); self.use_nvenc.setChecked(bool(self.settings.get("use_nvenc", False)))
        adv_l.addWidget(self.use_nvenc,3,2)
        adv_l.addWidget(QtWidgets.QLabel("x264 preset:"),4,0)
        self.x264_preset = QtWidgets.QComboBox(); self.x264_preset.addItems(["ultrafast","superfast","veryfast","faster","fast","medium"])
        self.x264_preset.setCurrentText(self.settings.get("x264_preset","veryfast"))
        adv_l.addWidget(self.x264_preset,4,1)
        self.minlog_check = QtWidgets.QCheckBox("Minimal logging (to file)"); self.minlog_check.setChecked(bool(self.settings.get("minimal_logging", True)))
        adv_l.addWidget(self.minlog_check,5,0,1,3)

        adv_sec.setContentLayout(adv_l)
        outer.addWidget(adv_sec)

        # Populate and tooltips
        QtCore.QTimer.singleShot(100, self._populate_models_async)
        QtCore.QTimer.singleShot(150, self._apply_tooltips)
        self._on_preset_changed(self.rife_preset.currentText())

    # ---------- UI helpers ----------
    def _log(self, s:str):
        self.log.appendPlainText(s)

    def _status(self, s:str):
        self.status_lbl.setText(s)

    def _progress(self, v:int):
        self.prog.setValue(v)

    def _browse_in(self):
        fn,_ = QtWidgets.QFileDialog.getOpenFileName(self, "Choose input video", "", "Videos (*.mp4 *.mov *.mkv *.avi *.webm);;All Files (*)")
        if fn:
            self.in_edit.setText(fn)
            if not self.out_edit.text().strip():
                p = Path(fn)
                suggested = Path(self.output_base.text().strip() or str(OUTPUT_DEFAULT)) / (p.stem + "_rife.mp4")
                self.out_edit.setText(str(suggested))

    def _browse_out(self):
        base = self.output_base.text().strip() or str(OUTPUT_DEFAULT)
        fn,_ = QtWidgets.QFileDialog.getSaveFileName(self, "Choose output video", base, "MP4 Video (*.mp4);;MKV Video (*.mkv);;All Files (*)")
        if fn:
            self.out_edit.setText(fn)

    def _choose_output_base(self):
        cur = self.output_base.text().strip() or str(OUTPUT_DEFAULT)
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, "Choose output base folder", cur)
        if folder:
            self.output_base.setText(folder)
            self.settings["output_base"] = folder
            write_json(SETTINGS_PATH, self.settings)
            if self.in_edit.text().strip() and not self.out_edit.text().strip():
                p = Path(self.in_edit.text().strip())
                self.out_edit.setText(str(Path(folder) / (p.stem + "_rife.mp4")))

    def _open_output_base(self):
        base = Path(self.output_base.text().strip() or str(OUTPUT_DEFAULT))
        base.mkdir(parents=True, exist_ok=True)
        try:
            if is_windows(): os.startfile(str(base))
            elif platform.system()=="Darwin": subprocess.Popen(["open", str(base)])
            else: subprocess.Popen(["xdg-open", str(base)])
        except Exception:
            pass

    def _populate_models_async(self):
        def task():
            try:
                self.tm.ensure_rife()
                choices=["Auto"]
                if MODELS_DIR.exists():
                    def allowed(name: str) -> bool:
                        n = name.lower()
                        return (n.startswith("rife-v4") or n.startswith("rife-hd") or n.startswith("rife-uhd") or n.startswith("rife-anime"))
                    for d in sorted(MODELS_DIR.iterdir()):
                        if d.is_dir() and allowed(d.name):
                            choices.append(d.name)
                self.modelsReady.emit(choices)
            except Exception as e:
                self._log(f"Model scan failed: {e}")
        threading.Thread(target=task, daemon=True).start()

    @QtCore.Slot(list)
    def _set_model_choices(self, choices: list):
        self.model_combo.clear(); self.model_combo.addItems(choices)
        fm = self.model_combo.fontMetrics(); w = 120
        for s in choices:
            w = max(w, fm.horizontalAdvance(s) + 36)
        view = QtWidgets.QListView(); view.setMinimumWidth(w); self.model_combo.setView(view)
        want = self.settings.get("model_choice","Auto")
        if want in choices: self.model_combo.setCurrentText(want)

    def _on_preset_changed(self, text: str):
        mapping = {"Turbo":"2:3:3", "Balanced":"1:2:2", "Eco":"1:1:1"}
        if text in mapping:
            self.thread_edit.setText(mapping[text])
            self.thread_edit.setEnabled(False)
        else:
            self.thread_edit.setEnabled(True)

    def _start(self):
        iv = self.in_edit.text().strip()
        base_dir = Path(self.output_base.text().strip() or str(OUTPUT_DEFAULT))
        base_dir.mkdir(parents=True, exist_ok=True)
        if not iv or not os.path.isfile(iv):
            QtWidgets.QMessageBox.warning(self, "Missing file", "Please choose a valid input video.")
            return
        ov = self.out_edit.text().strip()
        if not ov:
            p = Path(iv); ov = str(base_dir / (p.stem + "_rife.mp4")); self.out_edit.setText(ov)

        self.go_btn.setEnabled(False); self.cancel_btn.setEnabled(True)
        self.log.clear(); self.status_lbl.setText("Starting ..."); self.prog.setValue(0)

        self.settings.update({
            "last_input": iv, "last_output": ov, "last_fps": self.fps_spin.value(),
            "thread_spec": self.thread_edit.text().strip(), "gpu_choice": self.gpu_combo.currentText(),
            "model_choice": self.model_combo.currentText(), "keep_temp": self.keep_temp.isChecked(),
            "cpu_fallback": self.cpu_fallback.isChecked(), "uhd_safety": self.uhd_check.isChecked(),
            "output_base": str(base_dir), "mode": "factor" if self.mode_factor.isChecked() else "fps",
            "factor": int(self.factor_combo.currentText()), "streaming": self.streaming_check.isChecked(),
            "chunk_size": int(self.chunk_spin.value()), "crf": int(self.crf_spin.value()),
            "minimal_logging": self.minlog_check.isChecked(),
            "rife_preset": self.rife_preset.currentText(), "pace_ms": int(self.pace_spin.value()),
            "png_level": int(self.png_level.value()), "use_jpeg": self.use_jpeg.isChecked(),
            "jpeg_q": int(self.jpeg_q.value()), "use_nvenc": self.use_nvenc.isChecked(),
            "x264_preset": self.x264_preset.currentText(),
        })
        write_json(SETTINGS_PATH, self.settings)

        self.thread = QtCore.QThread(self)
        self.worker = InterpWorker(self.tm, self.settings); self.worker.moveToThread(self.thread)
        self.worker.log.connect(self._log); self.worker.status.connect(self._status); self.worker.progress.connect(self._progress); self.worker.finished.connect(self._finished)
        self.thread.started.connect(lambda: self.worker.run(
            iv, ov, self.fps_spin.value(), self.model_combo.currentText(), self.gpu_combo.currentText(),
            self.thread_edit.text().strip(), self.keep_temp.isChecked(), self.cpu_fallback.isChecked(),
            "factor" if self.mode_factor.isChecked() else "fps", int(self.factor_combo.currentText()),
            self.streaming_check.isChecked(), int(self.chunk_spin.value()), self.uhd_check.isChecked(),
            self.minlog_check.isChecked(), self.rife_preset.currentText(), int(self.pace_spin.value()),
            int(self.png_level.value()), self.use_jpeg.isChecked(), int(self.jpeg_q.value()),
            self.use_nvenc.isChecked(), self.x264_preset.currentText()
        ))
        self.thread.start()

    def _cancel(self):
        if hasattr(self,"worker"): self.worker.cancel()
        self._log("Cancellation requested.")

    def _finished(self, ok: bool, out_path: str):
        self.go_btn.setEnabled(True); self.cancel_btn.setEnabled(False)
        if ok:
            self._log(f"✅ Done: {out_path}")
            QtWidgets.QMessageBox.information(self, "Done", f"Finished!\n\n{out_path}")
        else:
            self._log("❌ Failed. Check logs above.")
            QtWidgets.QMessageBox.critical(self, "Failed", "Interpolation failed. See log.")

    def _apply_tooltips(self):
        self.in_edit.setToolTip("Path to the source video. Supported by FFmpeg (MP4, MOV, MKV, WEBM, etc.).")
        self.output_base.setToolTip("Base folder where your rendered videos will be saved by default.")
        self.out_edit.setToolTip("Final output file path. If empty, we auto-suggest <input_name>_rife.mp4 inside the output folder.")
        self.mode_fps.setToolTip("Generate video at an exact target frame rate (e.g., 60 FPS).")
        self.fps_spin.setToolTip("Exact output FPS when using 'Exact FPS' mode.")
        self.mode_factor.setToolTip("Multiply the input FPS by a factor (×2 or ×4).")
        self.factor_combo.setToolTip("Interpolation factor when using 'Factor' mode: ×2 or ×4.")
        self.go_btn.setToolTip("Start interpolation.")
        self.cancel_btn.setToolTip("Cancel the current job (best-effort).")
        self.model_combo.setToolTip("Model to use (NOT an upscaler). Only rife-v4*/HD/UHD/anime are shown. Auto picks newest v4.* for -n support.")
        self.gpu_combo.setToolTip("Which device(s) RIFE uses. Auto picks best GPU. 'CPU (-1)' forces CPU. '0,1' targets specific GPUs.")
        self.thread_edit.setToolTip("RIFE threading layout: load:proc:save (e.g., 1:2:2). Controls IO/compute/save workers.")
        self.streaming_check.setToolTip("Process frames in smaller chunks to lower VRAM/RAM usage. Safer on tight systems; slightly slower.")
        self.chunk_spin.setToolTip("Chunk size when Streaming is ON. Larger = faster but higher memory usage (1-frame overlap handled).")
        self.rife_preset.setToolTip("Presets for RIFE threads. Turbo=2:3:3, Balanced=1:2:2, Eco=1:1:1. 'Custom' unlocks manual editing.")
        self.pace_spin.setToolTip("Sleep this many milliseconds between streaming chunks to reduce contention. Use with Streaming.")
        self.crf_spin.setToolTip("Quality for the final encode. Lower CRF = higher quality and larger files. Range 0–51.")
        self.uhd_check.setToolTip("Enable UHD safety flag (-u) for very high resolutions to avoid out-of-memory in the model.")
        self.keep_temp.setToolTip("Keep the extracted and interpolated frames after encoding (useful for debugging).")
        self.cpu_fallback.setToolTip("If GPU/Vulkan fails, retry on CPU automatically (slower but robust).")
        self.minlog_check.setToolTip("Write full process logs to a file and keep the UI smooth by not streaming every log line.")
        self.png_level.setToolTip("PNG compression level for temp frames. 0 = fastest (default), 9 = smallest files (more CPU).")
        self.use_jpeg.setToolTip("Use JPEG temp frames (MJPEG) instead of PNG to reduce disk usage/IO. Slight quality tradeoff; good on HDDs.")
        self.jpeg_q.setToolTip("JPEG quality for temp frames (2 = best quality; higher numbers reduce quality but are smaller).")
        self.use_nvenc.setToolTip("Use NVIDIA NVENC for the final video encode to offload CPU. Falls back to libx264 if not available.")
        self.x264_preset.setToolTip("x264 speed/quality preset when not using NVENC. 'ultrafast' uses least CPU; 'medium' compresses better.")
        self.status_lbl.setToolTip("High-level status of the current step.")
        self.prog.setToolTip("Overall progress updated live across Decode / RIFE / Encode phases. Scroll the log if it gets long.")
        self.log.setToolTip("Detailed log output.")

# Optional: tiny collapsible section
class CollapsibleSection(QtWidgets.QWidget, *args, **kwargs):
    def __init__(self, title: str, start_collapsed: bool = True, parent=None, *args, **kwargs):
        super().__init__(parent)
        self.toggle = QtWidgets.QToolButton(text=title, checkable=True, checked=not start_collapsed)
        self.toggle.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
        self.toggle.setArrowType(QtCore.Qt.DownArrow if not start_collapsed else QtCore.Qt.RightArrow)
        self.toggle.clicked.connect(self._on_toggle)
        self.toggle.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.toggle.setCursor(QtCore.Qt.PointingHandCursor)
        self.content = QtWidgets.QWidget(); self.content.setVisible(not start_collapsed)
        lay = QtWidgets.QVBoxLayout(self); lay.setContentsMargins(0,0,0,0); lay.addWidget(self.toggle); lay.addWidget(self.content)
        self.v = QtWidgets.QVBoxLayout(self.content); self.v.setContentsMargins(16,8,8,8); self.v.setSpacing(6)
    def setContentLayout(self, layout: QtWidgets.QLayout):
        while self.v.count():
            item = self.v.takeAt(0); w = item.widget()
            if w: w.deleteLater()
        self.v.addLayout(layout)
    def _on_toggle(self, checked: bool):
        self.toggle.setArrowType(QtCore.Qt.DownArrow if checked else QtCore.Qt.RightArrow)
        self.content.setVisible(checked)

# -*- coding: utf-8 -*-
import re

def _slug_title(t:str)->str:
    try:
        return re.sub(r'[^a-z0-9]+','_', (t or '').lower()).strip('_')
    except Exception:
        return 'section'

"""
RifeTab: drop-in PySide6 QWidget to embed in your existing QTabWidget.
- Uses bin/, models/, output/video/interpolated/ next to this file's parent folder (same layout you use).
- Model picker filtered to rife-v4*/HD/UHD/anime; only copies those from the release.
- One visible "Progress" section under Start/Cancel; window scroll handled by host app.
- CPU fallback OFF by default; pace default 100ms.
- Preset↔Threads sync (Turbo=2:3:3, Balanced=1:2:2, Eco=1:1:1; Custom unlocks).
"""
