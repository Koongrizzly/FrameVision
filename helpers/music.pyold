
# Music module for FrameVision
# - Adds animated audio "visualizations" (GIF/animated bars fallback)
# - Shows cover art (if available) + metadata (title/artist/album)
# - Minimal playlist UI (floating overlay in the player)
# - Auto-switch visualizations every N beats (16/32/64) using TBPM tag if present, otherwise 120 BPM
#
# This module monkeypatches VideoPane.open with a wrapper that triggers when an audio file is loaded.
# It draws visuals+cover into the existing left player's label (no external window).
# Fullscreen keeps the existing slider + play/pause overlay from VideoPane.

from __future__ import annotations
import os, subprocess, random, time, json, math
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, List, Tuple

from PySide6.QtCore import Qt, QTimer, QRect, QSize, Signal, QObject, QUrl
from PySide6.QtGui import QPixmap, QImage, QPainter, QColor, QFont
from PySide6.QtWidgets import QWidget, QLabel, QVBoxLayout, QHBoxLayout, QPushButton, QListWidget, QListWidgetItem, QFrame, QFileDialog, QComboBox, QCheckBox

# --- small local helpers (avoid circular imports) ---
ROOT = Path(".").resolve()
BASE = ROOT
OUT_TEMP = BASE / "output" / "_temp"
OUT_TEMP.mkdir(parents=True, exist_ok=True)

AUDIO_EXTS = {'.mp3','.wav','.flac','.m4a','.aac','.ogg','.opus','.wma','.aif','.aiff'}

def ffmpeg_path():
    candidates = [ROOT/"bin"/("ffmpeg.exe" if os.name=="nt" else "ffmpeg"), "ffmpeg"]
    for c in candidates:
        try:
            subprocess.check_output([str(c), "-version"], stderr=subprocess.STDOUT, text=True)
            return str(c)
        except Exception:
            continue
    return "ffmpeg"

def ffprobe_path():
    candidates = [ROOT/"bin"/("ffprobe.exe" if os.name=="nt" else "ffprobe"), "ffprobe"]
    for c in candidates:
        try:
            subprocess.check_output([str(c), "-version"], stderr=subprocess.STDOUT, text=True)
            return str(c)
        except Exception:
            continue
    return "ffprobe"

def _read_tags_with_ffprobe(path: Path) -> dict:
    try:
        out = subprocess.check_output([ffprobe_path(), "-v","error", "-show_format", "-show_streams", "-of","json", str(path)], text=True)
        data = json.loads(out)
        tags = {}
        fmt = data.get("format",{}).get("tags",{}) if isinstance(data, dict) else {}
        if isinstance(fmt, dict):
            tags.update(fmt)
        # Try stream tags too
        for st in data.get("streams",[]) or []:
            if isinstance(st, dict):
                tt = st.get("tags",{})
                if isinstance(tt, dict):
                    for k,v in tt.items():
                        tags.setdefault(k, v)
        return tags
    except Exception:
        return {}

def _has_attached_pic(path: Path) -> bool:
    try:
        out = subprocess.check_output([ffprobe_path(), "-v","error","-select_streams","v","-show_entries","stream=disposition,codec_type","-of","json", str(path)], text=True)
        data = json.loads(out)
        for st in data.get("streams",[]) or []:
            disp = st.get("disposition",{})
            if isinstance(disp, dict) and int(disp.get("attached_pic",0)) == 1:
                return True
    except Exception:
        pass
    return False

def _extract_cover(path: Path) -> Optional[Path]:
    """Try to extract cover art (attached_pic) into OUT_TEMP and return file path."""
    try:
        if not _has_attached_pic(path):
            return None
        stem = path.stem
        out = OUT_TEMP / f"{stem}_cover.jpg"
        cmd = [ffmpeg_path(), "-y", "-i", str(path), "-an", "-vcodec", "copy", str(out)]
        subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True)
        if out.exists() and out.stat().st_size > 0:
            return out
    except Exception:
        pass
    return None

def _qimage_from_pixmap(pm: QPixmap) -> QImage:
    if pm is None or pm.isNull():
        return QImage()
    return pm.toImage()

def _scaled(pm: QPixmap, size: QSize) -> QPixmap:
    if pm is None or pm.isNull(): return pm
    try:
        return pm.scaled(size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
    except Exception:
        return pm

# --- Visuals ---

class VisualEngine(QObject):
    """Very safe, always-moving visuals with time-based animation (no audio probe required).
       Optionally plays any .gif found under presets/viz/* (ensures constant motion with QMovie Fallback).
    """
    frameReady = Signal(QImage)  # emitted when a new frame is rendered
    
    def __init__(self, parent: Optional[QObject]=None):
        super().__init__(parent)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._tick)
        self.target_size = QSize(800, 800)
        self.start_time = time.time()
        self._mode = "bars"  # "bars" | "pulse" | "gif"
        self._gif = None
        self._gif_idx = -1
        self._gifs: List[Path] = []
        self._seed = random.random()*1000.0
        # scan visuals folder
        self._scan_visuals()
        if self._gifs:
            self._mode = "gif"
            self._gif_idx = 0
            self._load_gif(self._gifs[self._gif_idx])
        else:
            # default to bars
            self._mode = "bars"

    def _scan_visuals(self):
        try:
            base = ROOT / "presets" / "viz"
            if not base.exists():
                return
            for p in base.rglob("*"):
                if p.suffix.lower() in {".gif"}:
                    self._gifs.append(p)
            random.shuffle(self._gifs)
        except Exception:
            pass

    def _load_gif(self, path: Path):
        try:
            from PySide6.QtGui import QMovie
            self._gif = QMovie(str(path))
            self._gif.jumpToFrame(0)
        except Exception:
            self._gif = None
            self._mode = "bars"

    def set_target(self, size: QSize):
        self.target_size = size

    def start(self, fps: int = 30):
        self.timer.start(int(1000/max(1,fps)))

    def stop(self):
        self.timer.stop()

    def _tick(self):
        w = max(64, self.target_size.width())
        h = max(64, self.target_size.height())
        img = QImage(w, h, QImage.Format_RGBA8888)
        img.fill(QColor(10,10,12,255))
        p = QPainter(img)
        try:
            if self._mode == "gif" and self._gif is not None:
                # advance gif
                try:
                    f = self._gif.currentPixmap()
                    self._gif.jumpToNextFrame()
                    pm = _scaled(f, QSize(w, h))
                    p.drawPixmap((w-pm.width())//2, (h-pm.height())//2, pm)
                except Exception:
                    self._mode = "bars"  # fallback
            if self._mode == "bars":
                # animated bars driven by time (always moving)
                t = (time.time() - self.start_time) + self._seed
                bars = 48
                for i in range(bars):
                    phase = t*1.8 + i*0.33
                    val = 0.5 + 0.5*math.sin(phase)  # 0..1
                    val *= (0.7 + 0.3*math.sin(phase*0.77))
                    bw = w//bars + 1
                    bh = int(val * (h*0.85))
                    x = i*bw
                    y = (h-bh)//2
                    col = QColor.fromHsv(((i*7)+int(t*20))%360, 180, 240, 255)
                    p.fillRect(QRect(x, y, bw-1, bh), col)
                # a soft vignette
                p.setPen(Qt.NoPen)
                p.setBrush(QColor(0,0,0,90))
                p.drawRect(0,0,w,10); p.drawRect(0,h-10,w,10)
            if self._mode == "pulse":
                t = (time.time() - self.start_time) + self._seed
                cx, cy = w//2, h//2
                maxr = min(w,h)//2 - 8
                rings = 12
                for i in range(rings):
                    phase = t*2.0 + i*0.6
                    r = int(maxr * (0.1 + 0.9*(0.5+0.5*math.sin(phase))))
                    col = QColor.fromHsv((int(phase*40) + i*15)%360, 200, 255, 160)
                    p.setPen(col); p.setBrush(Qt.NoBrush)
                    p.drawEllipse(cx-r, cy-r, r*2, r*2)
        finally:
            p.end()
        self.frameReady.emit(img)

    def next_visual(self):
        if self._gifs:
            self._mode = "gif"
            self._gif_idx = (self._gif_idx + 1) % len(self._gifs)
            self._load_gif(self._gifs[self._gif_idx])
        else:
            # swap between bars and pulse for built-in variety
            self._mode = "pulse" if self._mode == "bars" else "bars"


@dataclass
class TrackInfo:
    path: Path
    title: str = ""
    artist: str = ""
    album: str = ""
    bpm: int = 120

class MusicOverlay(QWidget):
    """A small overlay inside the video pane with cover+tags, playlist and visual settings."""
    def __init__(self, video_pane, parent=None):
        super().__init__(parent or video_pane)
        self.setAttribute(Qt.WA_TransparentForMouseEvents, False)
        self.setAutoFillBackground(False)
        self.setObjectName("musicOverlay")
        self.video = video_pane

        self.setStyleSheet("#musicOverlay { background: rgba(0,0,0,120); border-radius: 12px; } QLabel, QListWidget { color: white; } QPushButton { background: rgba(255,255,255,30); border: none; padding: 6px 10px; border-radius: 8px;} QPushButton:hover{background: rgba(255,255,255,45);}")

        self.lbl_cover = QLabel()
        self.lbl_cover.setFixedSize(120,120)
        self.lbl_title = QLabel("—")
        self.lbl_artist = QLabel("")
        self.lbl_album = QLabel("")
        f = self.lbl_title.font(); f.setPointSize(max(11, f.pointSize()+2)); f.setBold(True); self.lbl_title.setFont(f)

        meta_box = QVBoxLayout()
        meta_box.addWidget(self.lbl_title)
        meta_box.addWidget(self.lbl_artist)
        meta_box.addWidget(self.lbl_album)

        self.playlist = QListWidget()
        self.playlist.setFixedWidth(260)
        self.btn_add = QPushButton("Add…")
        self.btn_clear = QPushButton("Clear")
        self.btn_prev = QPushButton("⏮")
        self.btn_next = QPushButton("⏭")
        row_btns = QHBoxLayout(); [row_btns.addWidget(b) for b in (self.btn_add, self.btn_clear, self.btn_prev, self.btn_next)]; row_btns.addStretch(1)

        # Visual controls
        self.chk_auto = QCheckBox("Auto-change visuals")
        self.cmb_beats = QComboBox(); self.cmb_beats.addItems(["16","32","64"]); self.cmb_beats.setCurrentIndex(1)
        row_vis = QHBoxLayout(); row_vis.addWidget(self.chk_auto); row_vis.addWidget(QLabel("Every")); row_vis.addWidget(self.cmb_beats); row_vis.addWidget(QLabel("beats")); row_vis.addStretch(1)

        # Layout
        left = QHBoxLayout()
        left.addWidget(self.lbl_cover)
        left.addLayout(meta_box)
        left.addStretch(1)

        main = QVBoxLayout(self)
        main.setContentsMargins(10,10,10,10)
        top = QHBoxLayout()
        top.addLayout(left, 1)
        top.addWidget(self.playlist, 0)
        main.addLayout(top)
        main.addLayout(row_btns)
        main.addLayout(row_vis)

        # signals
        self.btn_add.clicked.connect(self._add_files)
        self.btn_clear.clicked.connect(self.playlist.clear)
        self.btn_prev.clicked.connect(lambda: self._jump(-1))
        self.btn_next.clicked.connect(lambda: self._jump(+1))
        self.playlist.itemDoubleClicked.connect(self._play_clicked)

        # internal
        self._tracks: List[TrackInfo] = []
        self._current_idx = -1

        # ensure overlay sits at bottom-left inside the video pane
        self._reposition()
        self.show()

    def _reposition(self):
        vp = self.video
        try:
            r = vp.label.geometry()
        except Exception:
            r = self.video.geometry()
        W = min(560, int(r.width()*0.9))
        H = min(260, int(r.height()*0.6))
        x = r.x() + 10
        y = r.y() + max(10, r.height() - H - 10)
        self.setGeometry(x, y, W, H)

    def resizeEvent(self, e):
        super().resizeEvent(e)
        # keep position relative to video label
        QTimer.singleShot(0, self._reposition)

    def _add_files(self):
        # NOTE: QFileDialog parent is the main window
        mw = self.video.window()
        paths, _ = QFileDialog.getOpenFileNames(mw, "Add audio files", str(ROOT), "Audio files (*.mp3 *.wav *.flac *.m4a *.aac *.ogg *.opus *.wma *.aif *.aiff)")
        for p in paths:
            self.add_track(Path(p))

    def add_track(self, path: Path):
        i = TrackInfo(path=Path(path))
        self._tracks.append(i)
        it = QListWidgetItem(path.name)
        self.playlist.addItem(it)

    def _play_clicked(self, item: QListWidgetItem):
        idx = self.playlist.row(item)
        if 0 <= idx < len(self._tracks):
            self._current_idx = idx
            self.video.open(self._tracks[idx].path)

    def _jump(self, delta: int):
        if not self._tracks:
            return
        if self._current_idx < 0:
            self._current_idx = 0
        else:
            self._current_idx = (self._current_idx + delta) % len(self._tracks)
        self.video.open(self._tracks[self._current_idx].path)

    # exposed setters
    def set_meta(self, title: str, artist: str, album: str, cover_pm: Optional[QPixmap]):
        self.lbl_title.setText(title or "—")
        self.lbl_artist.setText(artist or "")
        self.lbl_album.setText(album or "")
        if cover_pm and not cover_pm.isNull():
            self.lbl_cover.setPixmap(cover_pm.scaled(self.lbl_cover.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
        else:
            pm = QPixmap(self.lbl_cover.size())
            pm.fill(QColor(30,30,34))
            painter = QPainter(pm); painter.setPen(QColor(200,200,200)); painter.drawText(pm.rect(), Qt.AlignCenter, "♪"); painter.end()
            self.lbl_cover.setPixmap(pm)

    def current_auto_beats(self) -> int:
        try:
            return int(self.cmb_beats.currentText())
        except Exception:
            return 32

    def is_auto(self) -> bool:
        return bool(self.chk_auto.isChecked())


class MusicRuntime(QObject):
    """Keeps runtime state for an active audio file and renders the composite (cover+visual)."""
    def __init__(self, video_pane):
        super().__init__(video_pane)
        self.video = video_pane
        self.overlay: Optional[MusicOverlay] = None
        self.visual = VisualEngine(self)
        self.visual.frameReady.connect(self._on_visual_frame)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._update)
        self.cover: Optional[QPixmap] = None
        self.meta: TrackInfo = TrackInfo(path=Path("."))
        self._last_beat_index = -1

    def start(self):
        self.visual.set_target(self.video.label.size())
        self.visual.start(30)
        self.timer.start(1000//30)

    def stop(self):
        self.timer.stop()
        self.visual.stop()

    def _on_visual_frame(self, img: QImage):
        # Compose: background = visual, draw cover box + text on top; then set to the player's label as pixmap
        w = max(64, self.video.label.width())
        h = max(64, self.video.label.height())
        base = QImage(w, h, QImage.Format_RGBA8888)
        base.fill(QColor(5,5,7,255))
        p = QPainter(base)
        try:
            # draw visual centered
            pm = QPixmap.fromImage(img)
            pm = _scaled(pm, QSize(w, h))
            p.drawPixmap((w-pm.width())//2, (h-pm.height())//2, pm)

            # glass panel
            p.fillRect(QRect(18, 18, min(520, int(w*0.7)), 148), QColor(0,0,0,140))

            # cover
            if self.cover and not self.cover.isNull():
                cpm = _scaled(self.cover, QSize(120,120))
                p.drawPixmap(26, 26, cpm)

            # text
            p.setPen(QColor(255,255,255))
            font = QFont(); font.setPointSize(14); font.setBold(True); p.setFont(font)
            p.drawText(QRect(160, 28, w-180, 28), Qt.AlignLeft|Qt.AlignVCenter, self.meta.title or self.meta.path.name)
            font = QFont(); font.setPointSize(11); p.setFont(font)
            if self.meta.artist:
                p.drawText(QRect(160, 60, w-180, 24), Qt.AlignLeft|Qt.AlignVCenter, self.meta.artist)
            if self.meta.album:
                p.drawText(QRect(160, 86, w-180, 24), Qt.AlignLeft|Qt.AlignVCenter, self.meta.album)

        finally:
            p.end()

        self.video.label.setPixmap(QPixmap.fromImage(base))

    def _update(self):
        # heartbeat for beat-based auto change
        dur_bpm = max(1, int(self.meta.bpm or 120))
        ms_per_beat = 60000 // dur_bpm
        pos = 0
        try:
            pos = int(self.video.player.position())
        except Exception:
            pos = 0
        beat_index = pos // ms_per_beat
        overlay = self.overlay
        if overlay and overlay.is_auto():
            N = max(1, overlay.current_auto_beats())
            if beat_index != self._last_beat_index and (beat_index % N) == 0 and beat_index>0:
                self.visual.next_visual()
        self._last_beat_index = beat_index

    def set_overlay(self, overlay: MusicOverlay):
        self.overlay = overlay

    def set_cover(self, pm: Optional[QPixmap]):
        self.cover = pm

    def set_meta(self, meta: TrackInfo):
        self.meta = meta
        # sync overlay labels too
        if self.overlay:
            self.overlay.set_meta(meta.title, meta.artist, meta.album, self.cover)


# --- Monkeypatch wiring ---

def wire_to_videopane(VideoPaneClass):
    """Monkeypatch VideoPane.open so audio files render through MusicRuntime."""
    if getattr(VideoPaneClass, "_music_wired", False):
        return
    VideoPaneClass._music_wired = True

    orig_open = VideoPaneClass.open

    def open_wrapper(self, path):
        p = Path(str(path))
        ext = p.suffix.lower()
        if ext in AUDIO_EXTS:
            # Let the original set up the player + slider (no external windows)
            result = orig_open(self, path)

            # Build or reuse the overlay & runtime
            if not hasattr(self, "_music_runtime") or self._music_runtime is None:
                self._music_runtime = MusicRuntime(self)
            rt = self._music_runtime

            # Overlay (create or update)
            if not hasattr(self, "_music_overlay") or self._music_overlay is None:
                self._music_overlay = MusicOverlay(self, parent=self)
                rt.set_overlay(self._music_overlay)
            # Extract tags/cover
            tags = _read_tags_with_ffprobe(p)
            title = tags.get("title") or tags.get("TITLE") or p.stem
            artist = tags.get("artist") or tags.get("ARTIST") or ""
            album = tags.get("album") or tags.get("ALBUM") or ""
            bpm = 0
            for key in ("TBPM","bpm","BPM","tbpm"):
                v = tags.get(key)
                if v:
                    try:
                        bpm = int(float(str(v).strip()))
                        break
                    except Exception:
                        pass
            if bpm <= 0: bpm = 120
            meta = TrackInfo(path=p, title=title, artist=artist, album=album, bpm=bpm)

            cover_pm = None
            cov_path = _extract_cover(p)
            if cov_path and cov_path.exists():
                cover_pm = QPixmap(str(cov_path))

            rt.set_cover(cover_pm)
            rt.set_meta(meta)
            rt.start()  # begin animation

            # ensure overlay visible & positioned
            try:
                self._music_overlay._reposition()
                self._music_overlay.show()
            except Exception:
                pass
            return result
        else:
            # Non-audio: clean up overlay runtime if present
            try:
                if hasattr(self, "_music_runtime") and self._music_runtime:
                    self._music_runtime.stop()
            except Exception:
                pass
            try:
                if hasattr(self, "_music_overlay") and self._music_overlay:
                    self._music_overlay.hide()
            except Exception:
                pass
            return orig_open(self, path)

    VideoPaneClass.open = open_wrapper
